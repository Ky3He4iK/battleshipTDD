package entity

import kotlin.random.Random

class Map(isAutoGenerated: Boolean) {
    private val boats = arrayListOf<Boat>()
    val cells: ArrayList<ArrayList<Point>> = ArrayList(List(10) { ArrayList(List(10) { Point() }) })

    init {
        if (isAutoGenerated)
            autoGen()
    }

    private fun autoGen() {
        for (boatLen in 1..4) {
            for (num in 1..5 - boatLen) {
                do {
                    val x = Random.nextInt(0, 10)
                    val y = Random.nextInt(0, 10)
                    val dir = Random.nextBoolean()
                } while (!setBoat(x, y, boatLen, dir) && !setBoat(x, y, boatLen, !dir))
            }
        }
    }

    fun setBoat(x: Int, y: Int, size: Int, isHorizontal: Boolean): Boolean {
        val xMax = if (isHorizontal) x + size - 1 else x
        val yMax = if (isHorizontal) y else y + size - 1
        //Check Boat has no collisions
        if (!(x..xMax).all { i -> (y..yMax).all { j -> hasNoCollisions(i, j) } })
            return false
        //Set boat
        val boat = Boat(arrayListOf())
        for (i in x..xMax) {
            for (j in y..yMax) {
                boat.coords.add(Pair(i, j))
                cells[i][j].isBoatCell = true
            }
        }
        boats.add(boat)
        return true
    }

    private fun hasNoCollisions(x: Int, y: Int): Boolean {
        if (!(x in 0 until 10 && y in 0 until 10))
            return false
        if (cells[x][y].isBoatCell)
            return false

        return (-1..1).all { dx -> (-1..1).all { dy -> isEmptyOrOutOfMap(x + dx, y + dy) } }
    }

    private fun isEmptyOrOutOfMap(x: Int, y: Int): Boolean {
        if (x in 0 until 10 && y in 0 until 10)
            return !cells[x][y].isBoatCell
        return true
    }

    fun hit(x: Int, y: Int): HitState {
        if (cells[x][y].isHitCell)
            return HitState.Empty
        cells[x][y].isHitCell = true
        if (cells[x][y].isBoatCell) {
            for (boat in boats) {
                //Check, if all boat cells are drowned
                val isDrowned = boat.coords.all { coord -> cells[coord.first][coord.second].isHitCell }
                // Hit around the boat, if they are drowned
                if (isDrowned) {
                    for (coord in boat.coords) {
                        (-1..1).forEach { dx -> (-1..1).forEach { dy -> setHit(coord.first + dx, coord.second + dy) } }
                    }
                }
            }
            return HitState.Hit
        }
        return HitState.Miss
    }

    private fun setHit(x: Int, y: Int) {
        if (x in 0 until 10 && y in 0 until 10)
            cells[x][y].isHitCell = true
    }

    fun isFleetDead(): Boolean {
        return boats.all { boat -> boat.coords.all { coord -> cells[coord.first][coord.second].isHitCell } }
    }

    enum class HitState {
        Hit, Miss, Empty, Error
    }
}
